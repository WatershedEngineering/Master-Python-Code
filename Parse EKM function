def readEKM(EKMport):

	def parse_EKM(response): #takes the response and parses it

		d = {}	#starts the dictionary

		def floatize8(string): #function for turning string
			length = len(string) #calculates the length of the string
			newstring = string[:-2] + "." + string[length-2:length] #inserts decimal point
			return newstring 
		def floatize4(string): #function for turning string
			length = len(string) #calculates the length of the string
			newstring = string[:-1] + "." + string[length-1:length] #inserts decimal point
			return newstring 
			

		d["Address"]= response[11:16] #12
		d["Total kWh"] = floatize8(response[16:24]) #8
		d["T1 kWh"] = floatize8(response[24:32]) #8
		d["T2 kWh"] = floatize8(response[32:40]) #8
		d["Tot Rev kWh"] = floatize8(response[56:64]) #8
		d["T1 Rev kWh"] = floatize8(response[64:72]) #8
		d["T2 Rev kWh"] = floatize8(response[72:80]) #8
		d["V1"] = floatize4(response[96:100]) #4
		d["V2"] = floatize4(response[100:104]) #4
		d["A1"] = floatize4(response[108:113]) #5
		d["A2"] = floatize4(response[113:118]) #5
		d["P1"] = response[123:130] #7
		d["P2"] = response[130:137] #7
		d["Total Power"] = response[144:151] #7
		return d #returns the dictionary

	ser=serial.Serial(EKMport,baudrate=9600,parity=serial.PARITY_EVEN,bytesize=serial.SEVENBITS) #setting up serial
	sequence = "\x2F\x3F\x00\x00\x00\x00\x00\x00\x00\x01\x04\x05\x01\x02\x0D\x0A" #sending the request sequence
	ser.write(sequence) #writes the request sequence
	response = ser.readline() #assigns the response a variable
	return parse_EKM(response) #returns the dictionary
	
return readEKM("/dev/ttyUSB2")
